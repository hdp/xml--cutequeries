=head1 NAME

XML::CuteQueries - A cute little query language for converting XML to Perl

=head1 SYNOPSIS

This is a cross between L<XML::Simple> (which isn't simple at all) and
L<XML::Twig> which is a pretty fun way to process XML documents.

    use strict;
    use warnings;
    use XML::CuteQueries;

    my $CQ = XML::CuteQueries->new;
       $CQ->parsefile("example.xml");

    my $result = $CQ->cute_query(result=>'');
    my $data   = $CQ->cute_query(data=>[row=>{'*'=>''}]);
    my @data   = $CQ->cute_query("/data/row/*" => '');
    my %fields = $CQ->hash_query("/data/row[1]/*" => '');
    my @rows   = $CQ->cute_query("/data/row" => {'*'=>''});

L<XML::CuteQueries> L<is a|perltoot/Inheritance> L<XML::Twig>, so when this
miniature query language isn't enough for your needs, you can just fall back on
the Twig methods.

This module isn't likely to do a lot more than the above so it can
I<remain simple>, something L<XML::Simple> forgot to do.

There is only one user method in this module and it just uses L<XML::Twig> to
return the data you asked for in a predicable perl structure (see L</ARRRRG> for
details on the author's perception of unpredictability using L<XML::Simple>).

Philosophically, this module aims to be really simple, but it does implement a
query language that must be learned.  It may be easier to skip ahead to the
L<examples|/EXAMPLES>.  The details of Cute Queries follow.

=head1 CUTE QUERIES

This module uses the Perl parser to implement a miniature query language called
I<Cute Queries>.  The queries are not proper Perl code in the traditional sense.
Although, they do parse as perl.

Cute queries are made up of pairs:

    $what_you_are_requesting => $the_target_data_shape

This detailed description here may be easier to follow if you take a look at the
L</EXAMPLES> section first -- it probably depends on your temperament.

=head2 B<C<$what_you_are_requesting>>

The C<$what_you_are_requesting> is specified with either
L<XPath|http://www.w3.org/TR/xpath> (as supported by L<XML::Twig>) or with
regular expressions.  Matching starts at the root element, rather than the
document.  This slightly differs from twig.

    $CQ->parse("<r><x><y>7</y></x></r>");

    my $res = $CQ->cute_query("." => ['//y'=>]); # $res is [7]
    my $res = $CQ->cute_query("x/y" => ''); # $res is 7

In pure twig, C<$twig->get_xpath("x/y")> would return an empty list (since the
document starts at C</> instead of C<< <r> >>.

Regular expression selectors are matched against each direct descendant one at a
time.

    $CQ->parse("<r><x>7</x><y>8</y></r>");

    my $res = $CQ->cute_query('.' => {qr([xy]) => ''});
    # $res is { x=>7, y=>8 }

In addition to regular expressions and L<XML::Twig>'s lighter version of XPath
(there is a heavy version, but it is unused here) CQ also supports a light
version of the attribute selector.

    $CQ->parse("<r> <d a='1' b='2'/> <d a='3' b='4'/> </r>");

    my @a = $CQ->cute_query('/r/d/@a'=>'', '/r/d/@b'=>'', 'd/@*'=>'');
    # @a = (1,2, 1,2,3,4)

CQ also supports an attribute selector that's completely illegal in real life
XPath: C<@*>.

    my @a = $CQ->cute_query(d=>{'@*'=>''});
    # @a = ({a=>1, b=>2}, {a=>3, b=>4})

The attribute matching XPath (and non XPath) expressions are limited to
attributes at the tail end of the path.  (Is there another kind?)

=head2 B<C<$the_target_data_type>>

There are three basic target shapes.

=over 4

=item B<C<''>>

The simplest target shape is C<''>.  Actually, non-reference scalar will do the
trick.  You cold use the string C<"data">, a C<0>, or even an
L<undef|perlfunc/undef>.

This means you'd like for the request to result in the string value of the
matches.

    my $res = $CQ->cute_query(field_name => '');
    # just returns the string in the <field_name> element.

This may produce an error if there's more than one C<< <field_name> >> though.
CQ will notice that the query is in a scalar context and will raise an error if
there's more than one match.

You can disable this behavior and instead return the I<first> match.  See
L</OPTIONS> for the full story on options.

    my $first_match = $CQ->cute_query( {nostrict=>1}, field_name=>1 );
    # return the first match, presuming there may be more than
    # one <field_name>

=item B<C<[]>>

The result shape of C<[]> indicates that what you're requesting should point to
an arrayref of items.  Those items are then named in a I<sub-query>.

    my @data = $CQ->cute_query( "data" => [] );
    # returns one empty arrayref for each <data> element matched

Typically, you would then put a I<sub-query> in the arrayref to indicate how to fill
it.  In the example below using the XML from L</EXAMPLES>, C<@data> would
contain one arrayref for each C<< <data> >> element.  There would be one hashref
for each C<< <row> >> element in the C<< <data> >> element, and that hashref
would be filled with one key/value pair for each field in the row.

    my @data = $CQ->cute_query( data=>[row=>{'*'=>''}] );

A I<sub-query> inside an arrayref (C<[]>) will have a preference for
I<not returning> the names of the tags it matches.

=item B<C<{}>>

The result shape of C<{}> indicates that what you're requesting should point to
a hashref of items.  Those items are then named in a I<sub-query>.

    my @data = $CQ->cute_query( "data/row" => {} );
    # returns one empty hashref for each row in each data element

Typically, you would then put a I<sub-query> in the hashref to indicate how to
fill it.  In the example below using the XML from L</EXAMPLES>, C<@data> would
contain one hashref for each C<< <row> >> element that is a chiled of a
C<< <data> >> element.  Each hashref is filled with key/value pairs for each
field in the row.

    my @data = $CQ->cute_query( "data/row" => {'*'=>''} );

A I<sub-query> inside an hashref (C<{}>) will have a preference for I<returning>
the names of the tags it matches as the keys of the values it finds.

=back

CQ keeps track of your preference for keys internally.  That is, if you want to
fill a hashref, it will return keys (the tag names) for the matched tags along
with the values.  Again, using the XML input data from L</EXAMPLES>, the
C<@ar_data> below will will not have field names, but the C<@hr_data> will.

    my @hr_data = $CQ->cute_query( "data/row" => {'*'=>''} );
    # ( {f1=>"blah", f2=>...}, {...}, ...)

    my @ar_data = $CQ->cute_query( "data/row" => ['*'=>''] );
    # ( ["blah", "blah"], [...], ...)
    # same thing without the key names

=head1 EXAMPLES

This is all a lot easier to explain by example.  For these examples, the
following XML source is assumed.

    <root>
        <result>OK</result>
        <data a="this'll be hard to fetch I think" b="I may need special handlers for @queries">
            <row> <f1>7</f1><f2>11</f2><f3>13</f3></row>
            <row><f1>17</f1><f2>19</f2><f3>23</f3></row>
            <row><f1>29</f1><f2>31</f2><f3>37</f3></row>
        </data>
        <atad>
            <c1><f1>503</f1><f1>509</f1></c1>
            <c2><f1>521</f1><f1>523</f1></c2>
        </atad>
    </root>

=head2 B<Example 1>

Grab the contents of each C<< <row> >> of each C<< <data> >> as an array ref of
hashrefs, with each key of each hashref being the name of the field tag and each
value the contents of the field tag.

    my $arrayref_of_hashrefs = $CQ->cute_query(
        # the top level query is for the <data> elements
        # the shape of the only top level query is [],
        # so it returns one [] -- for the one <data> element
        "data" => [
            # the contents of the top level [] is a sub query for row elements.
            # Each row element should be a hashref, so the data-[] will contain
            # three row-{} hashrefs
            row => {
                # the contents of those hashrefs is a subquery for any tag found
                # there.  The tag names are preserved as keys because we're
                # sitting in the context of a hashref.
                # the shape of each match result is '', so it just returns the
                # contents of each tag as a string.
                '*' => '',
            }
        ],
    );

The resulting Perl structure for this query is as follows:

    [ {f1=> 7, f2=>11, f3=>13},
      {f1=>17, f2=>19, f3=>23},
      {f1=>29, f2=>31, f3=>37}, ]

=head2 B<Example 2>

=head2 B<Example 3>

=head1 METHODS

=over 4

=item B<cute_query()>

The only method exposed by L<XML::CuteQueries> that doesn't come from
L<XML::Twig>.  It is the only real interface into the query language.
This function can take any number of arguments.

If the first argument is a hash ref, it's assumed to be an
L<options hashref|/OPTIONS>.  Otherwise, all arguments are assumed to be
L<query pairs|/CUTE QUERIES>.

The top level query tries to act like a I<sub-query> inside an arrayref L</[]>,
that is, it throws out the names of the matched tags and just returns the
values.

=item B<hash_query()> B<klist_query()>

This function is a wrapper for L</cute_query()> which simply adds the L</klist>
option to the query.

What this does in practice: it makes the query to act like a I<sub-query> inside
an hashref L</{}>, that is, it uses the matched tag names as keys and returns a
list of key/value pairs for the matched data.

=item B<parse()>

Choose this method to ask L<XML::Twig> to parse some XML.  See
L<XML::Twig/parse> for the full story.

=item B<parsefile()>

Choose this method to ask L<XML::Twig> to parse an external XML file.  See
L<XML::Twig/parsefile> for the full story.

=back

=head1 OPTIONS

=over 4

=item B<nostrict>

CQ crashes in various ways unless your patterns match precisely as you requested
them.  It may sometimes be desirable to continue matching and return appropriate
nothings instead.  Use this option to achieve that behavior.

    my $CQ = XML::CuteQueries
     ->new->parse("<r><x><y>7</y></x></r>");

    $CQ->cute_query("x/y", ''); # 7
    $CQ->cute_query("x/z", ''); # croaks()
    $CQ->cute_query({nostrict=>1}, "x/z", ''); # undef

=item B<klist>

By default, the top level L</cute_query()> will try to return a list (without
the matched tag names as keys).  Using this option will tell the top level to
preserve the matched field names and return a list of key/value pairs rather
than just the values.

    my @a = $CQ->cute_query("x"=>''): # match all <x> and return values as list
    my %h = $CQ->cute_query("*"=>''):
    # match all top level tags and return tag-name/value pairs

This can alternately be invoked by calling L</hash_query()>.

=item B<recurse_text>

By default, CQ will only return the text from the matched node when requesting
C<''> results.  If you'd like to return all the text, use this option.

    my $CQ = XML::CuteQueries
     ->new->parse("<r><p>Slow <em>down</em> there dude.</p></r>");

    my $r1 = $CQ->cute_query(p=>'');
    # Slow  there dude.

    my $r2 = $CQ->cute_query({recurse_text=>1}, p=>'');
    # Slow down there dude.

Note that CQ doesn't currently support slurping XML (or HTML) from the source
document.  There are no plans for this either.  If you need it, enter a wishlist
item on RT.

=item B<notrim>

By default, CQ will trim the leading and trailing space on each string result
without this option.  It will skip the trim on results that contain newlines.

    my $CQ = XML::CuteQueries
     ->new->parse("<r><x> 7</x><x> \n8</x></r>");

    my $r1 = $CQ->cute_query('.'=>[x=>'']);
    # $r1 is [7, " \n8"]

    my $r2 = $CQ->cute_query({notrim=>1}, '.'=>[x=>'']);
    # $r2 is [" 7", " \n8"]

=item B<nofilter_nontags>

    my $CQ = XML::CuteQueries
     ->new->parse("<r> <x>7</x> <x>8</x></r>");

By default, we skip the C<#PCDATA> "node" before the C<< <x> >>.

    my $r1 = $CQ->cute_query('.'=>[x=>'']);
    # $r1 is [7]

    my $r2 = $CQ->cute_query({nofilter_nontags=>1}, '.'=>[x=>'']);
    # $r2 is ['', 7, '', 8]

Preserving the text in a C<#PCDATA> requires L</notrim> (obviously), but also
seems to require L</recurse_text>.

    my $r3 = $CQ->cute_query(
        {notrim=>1, nofilter_nontags=1, recurse_text=>1},
        '.'=>[x=>'']);
    # $r3 is [' ', 7, ' ', 8]

=back

=head1 ARRRRG

Consider the following XML.

    <sql_result>
        <row><field1>x</field1> <field2>y</field2></row>
    </sql_result>

L<XML::Simple>'s C<XMLin()> will return this.

    { row => { field1 => "x", field2 => "y" } }

Now how about this?

    <sql_result>
        <row><field1>x</field1> <field2>y</field2></row>
        <row><field1>z</field1> <field2>w</field2></row>
    </sql_result>

Now we get this instead:

    { row => [
          { field1 => "x", field2 => "y" },
          { field1 => "z", field2 => "w" },
    ]}


Ahh, is C<row> a hashref or an arrayref of hashrefs?  This is the main Arrrg I
had with L<XML::Simple>.  I'm sure there's a way to solve this with
L<XML::Simple>, but I wouldn't want to have to figure it out.  The module is
just too complicated.

=head1 WHY CQ

L<XML::Twig> is pretty easy to use.  I'm also rather fond of L<XML::XPath>.  But
I found myself writing a great deal of Perl to get data from XML that I felt
like I should be able to get in one or two lines.

What I wanted was an explicit way to query data from the XML without
worrying about the problem listed in L</ARRRRG>.

=head1 AUTHOR

Paul Miller C<< <jettero@cpan.org> >>

I am using this software in my own projects...  If you find bugs, please
please please let me know.  Actually, let me know if you find it handy at
all.  Half the fun of releasing this stuff is knowing that people use it.

If you see anything wrong with the callbacks, the docs, or anything:  Definitely
let me know!  rt.cpan, irc, email, whatever.  Just let me know.

=head1 COPYRIGHT

Copyright (c) 2009 Paul Miller

=head1 SEE ALSO

perl(1), L<XML::Twig>, L<XML::CuteQueries::Error>
